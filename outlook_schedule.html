<!DOCTYPE html>
<!-- 
  === URL Parameters ===
  You can modify the page behavior using query parameters:

    
	?count=tomorrow  → Show events until end of tomorrow (default if not specified)
    ?count=today     → Show only events happening today
    ?count=3         → Show only the next 3 upcoming events 
    ?count=this_week → Show events for the current week
    ?count=all       → Show all future events

    ?now=2025-06-26T15:30:00 
        → Simulate the current time (useful for testing)
        Format: ISO 8601 (e.g. YYYY-MM-DDTHH:mm:ss)

    ?private=1       → Force private event details to be visible
    ?trans=1         → Makes the background transparent for embedding over a video/slideshow
-->
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <!-- DSEG font for 7-segment digital display -->
  <link href="https://cdn.jsdelivr.net/npm/dseg-fonts@2.0.0/dseg.css" rel="stylesheet">

  <title>Upcoming Events</title>
  <style>
    body {
      background-color: black;
      color: white;
      font-family: sans-serif;
      padding: 2em;
    }
    h1 {
      font-size: 2em;
      text-align: center;
    }
	#fullscreen {
	  display: none;
	  position: fixed;
	  inset: 0;
	  background: rgba(0,0,0,0.95);
	  z-index: 1000;
	  padding: 3em 1em 1em 1em;
	}
    .event {
      background-color: #222;
      border: 1px solid #555;
      border-radius: 12px;
      padding: 1em;
      margin-bottom: 1em;
      box-shadow: 0 2px 5px rgba(255, 255, 255, 0.1);
      position: relative;
      cursor: pointer;
      transition: transform 0.5s ease, opacity 0.5s ease;
    }
    .event strong {
      font-size: 1.2em;
      color: #4fc3f7;
    }
    .time-until {
      position: absolute;
      bottom: 8px;
      right: 12px;
      font-size: 0.9em;
      color: #ccc;
    }
    .big-time {
      position: static;
      font-size: 2em;
      font-weight: bold;
      color: #fff;
      text-align: center;
    }
    .starting-soon {
      border-color: orange;
      animation: pulseOrange 2s infinite alternate ease-in-out;
    }
    @keyframes pulseOrange {
      from { box-shadow: 0 0 10px orange; }
      to { box-shadow: 0 0 20px orange; }
    }
    .final-countdown {
      border-color: red;
      animation: pulseRed 2s infinite alternate ease-in-out;
      background-color: #400;
    }
    @keyframes pulseRed {
      from { box-shadow: 0 0 20px 5px red; background-color: #600; }
      to { box-shadow: 0 0 40px 15px red; background-color: #900; }
    }
    .happening-now {
      border-color: #aeefff;
      animation: pulseBlue 2s infinite alternate ease-in-out;
      background-color: #99ccff;
      color: black;
    }
    @keyframes pulseBlue {
      from { box-shadow: 0 0 10px #ffffff; background-color: #cceeff; }
      to { box-shadow: 0 0 20px #ffffff; background-color: #e0f7ff; }
    }
    .slide-out {
      transform: translateX(-100%);
      opacity: 0;
    }
    .slide-in {
      transform: translateX(100%);
      opacity: 0;
    }
    .slide-in-active {
      transform: translateX(0);
      opacity: 1;
    }
	.event-animating {
	  transition: transform 0.5s cubic-bezier(.34,1.56,.64,1);
	  z-index: 0;
	}
	.details-card {
	  background: #16181e;
	  border-radius: 16px;
	  box-shadow: 0 4px 24px rgba(80,200,255,0.12);
	  padding: 2em 2em 1.5em 2em;
	  color: #fff;
	  max-width: 450px;
	  margin: 2em auto 0 auto;
	  font-size: 1.08em;
	  border: 1.5px solid #4fc3f7;
    position: relative;
	}

	.details-title {
	  font-size: 1.7em;
	  color: #4fc3f7;
	  font-weight: 600;
	  margin-bottom: 0.4em;
	  text-align: center;
	  letter-spacing: 0.01em;
	}

	.details-row {
	  margin-bottom: 0.7em;
	  display: flex;
	  justify-content: flex-start;
	  gap: 0.5em;
	}

	.details-label {
	  color: #aeefff;
	  min-width: 90px;
	  font-weight: 500;
	  display: inline-block;
	}

	.details-date {
	  font-size: 1.1em;
	  color: #fff;
	  font-weight: 500;
	  margin-bottom: 1em;
	}

	.details-description {
	  margin-top: 1.5em;
	  font-size: 1em;
	  color: #dbefff;
	  line-height: 1.5;
	}

	.details-description .details-label {
	  min-width: 0;
	  font-weight: 600;
	  color: #4fc3f7;
	}

	.close-btn {
	  position: absolute;
	  top: 1em;
	  right: 1.2em;
	  background: #0c1820;
	  color: #4fc3f7;
	  border: none;
	  font-size: 2em;
	  font-weight: bold;
	  border-radius: 50%;
	  width: 1.6em;
	  height: 1.6em;
	  line-height: 1.2em;
	  text-align: center;
	  cursor: pointer;
	  box-shadow: 0 2px 10px #0005;
	  transition: background 0.2s, color 0.2s;
	  z-index: 10;
	}
	.close-btn:hover {
	  background: #223344;
	  color: #fff;
	}
	.details-card {
	  position: relative; /* Needed for the close button’s absolute positioning */
	}


    .date-divider {
      border-top: 2px solid #4fc3f7;
      margin: 1em 0;
      padding-top: 0.5em;
      font-size: 1.2em;
      color: #4fc3f7;
      text-align: center;
    }
	.event-time-row {
	  display: flex;
	  align-items: center;
	  gap: 1.3em;
	  font-size: 1.02em;
	  margin-bottom: 0.5em;
	}

	.event-duration {
	  color: #bbb;
	  font-size: 0.99em;
	}

	.event-dot {
	  color: #4fc3f7;
	  font-size: 1.3em;
	  line-height: 0.5;
	  margin-top: -2px;
	}
	
	/* Glow and pop-in for auto-triggered details */
	@keyframes popIn {
	  from {
		transform: scale(0.6);
		opacity: 0;
	  }
	  to {
		transform: scale(1);
		opacity: 1;
	  }
	}
#fullscreen.auto-glow .details-card {
  animation: popIn 0.3s ease-out, pulseJoinNow 0.6s ease-in-out infinite alternate;
  border-color: #33f3ff;
  box-shadow: 0 0 40px 20px #33f3ff;
  z-index: 2000;
}

@keyframes pulseJoinNow {
  from {
    box-shadow: 0 0 40px 10px #33f3ff;
    background-color: #0a2c38;
    border-color: #33f3ff;
  }
  to {
    box-shadow: 0 0 90px 40px #66fcff;
    background-color: #00475c;
    border-color: #66fcff;
  }
}


#current-time {
  font-family: 'DSEG7Classic-Regular', monospace;
  font-size: 4.5em;
  color: #33f3ff;
  text-align: center;
  letter-spacing: 0.12em;
  text-shadow:
    0 0 2px #0ff,
    0 0 4px #0ff;
}

/* --- All Day Events Styles --- */
#all-day-container {
    text-align: center;
    margin-bottom: 1.5em;
    padding: 1em 0;
    border-bottom: 1px solid #444;
}
.all-day-event {
    display: inline-block;
    background: #2a3b4d;
    color: #cdefff;
    padding: 0.4em 1em;
    border-radius: 16px;
    margin: 0 0.5em 0.5em 0;
    border: 1px solid #4fc3f7;
    font-size: 1em;
    cursor: pointer;
    transition: background-color 0.2s;
}
.all-day-event:hover {
    background-color: #4fc3f7;
    color: black;
}
.all-day-title {
    font-size: 1.2em;
    color: #4fc3f7;
    margin-bottom: 0.75em;
    text-transform: uppercase;
    letter-spacing: 0.1em;
}

/* --- NEW: Two-Column Layout Styles --- */
#main-content-wrapper {
    display: block; /* Default layout */
}
body.layout-split-column #main-content-wrapper {
    display: flex;
    gap: 2em;
    align-items: flex-start;
}
body.layout-split-column #all-day-container {
    flex: 1;
    max-width: 350px;
    border-bottom: none;
    padding: 0;
    margin-bottom: 0;
    text-align: left;
}
body.layout-split-column #events {
    flex: 2;
}
body.layout-split-column .all-day-event {
    display: block; /* Stack vertically in column */
    margin-bottom: 0.75em;
}


/* --- Settings Button and Modal Styles --- */
#settings-btn {
  position: fixed;
  top: 1.5em;
  left: 1.5em;
  width: 3em;
  height: 3em;
  background: #223344;
  color: #aeefff;
  border: 1.5px solid #4fc3f7;
  border-radius: 50%;
  font-size: 1.5em;
  cursor: pointer;
  z-index: 2000;
  transition: all 0.2s ease;
  display: flex;
  align-items: center;
  justify-content: center;
}
#settings-btn:hover {
  background: #4fc3f7;
  color: black;
  transform: rotate(45deg);
}
#settings-modal {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.8);
  z-index: 3000;
  padding: 2em;
  align-items: center;
  justify-content: center;
}
.settings-panel {
  background: #16181e;
  border-radius: 16px;
  padding: 2em;
  color: #fff;
  max-width: 500px;
  width: 100%;
  border: 1.5px solid #4fc3f7;
  position: relative;
}
.settings-panel h2 {
  text-align: center;
  font-size: 1.7em;
  color: #4fc3f7;
  margin-top: 0;
}
.setting-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 1.5em;
  font-size: 1.1em;
}
.setting-row label {
  color: #aeefff;
  font-weight: 500;
}
.setting-row input[type="text"] {
  background: #0c1820;
  color: white;
  border: 1px solid #4fc3f7;
  border-radius: 6px;
  padding: 0.5em;
  min-width: 200px;
}
#save-settings-btn {
  display: block;
  width: 100%;
  padding: 0.8em;
  background: #4fc3f7;
  color: black;
  border: none;
  border-radius: 8px;
  font-size: 1.2em;
  font-weight: bold;
  cursor: pointer;
  margin-top: 1em;
}

/* Styles for radio buttons */
.count-options-fieldset {
    border: 1px solid #4fc3f7;
    border-radius: 8px;
    padding: 1em;
    margin-bottom: 1.5em;
}
.count-options-fieldset legend {
    color: #aeefff;
    font-weight: 500;
    padding: 0 0.5em;
}
.radio-option {
    display: flex;
    align-items: center;
    margin-bottom: 0.75em;
}
.radio-option label {
    margin-left: 0.5em;
    flex-grow: 1;
}
#custom-count-input {
    width: 60px;
    margin-left: 0.5em;
    background: #0c1820;
    color: white;
    border: 1px solid #4fc3f7;
    border-radius: 4px;
    padding: 0.2em 0.5em;
}
#custom-count-input:disabled {
    background: #333;
    border-color: #555;
    cursor: not-allowed;
}

/* --- Slider Toggle Styles --- */
.switch {
  position: relative;
  display: inline-block;
  width: 50px;
  height: 28px;
}
.switch input { 
  opacity: 0;
  width: 0;
  height: 0;
}
.slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: #333;
  transition: .4s;
  border-radius: 28px;
  border: 1px solid #4fc3f7;
}
.slider:before {
  position: absolute;
  content: "";
  height: 20px;
  width: 20px;
  left: 3px;
  bottom: 3px;
  background-color: #aeefff;
  transition: .4s;
  border-radius: 50%;
}
input:checked + .slider {
  background-color: #4fc3f7;
}
input:checked + .slider:before {
  transform: translateX(22px);
  background-color: #0c1820;
}

/* --- Hide/Unhide Event Button Styles --- */
.details-action-btn {
    padding: 0.5em 1em;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.2s;
    margin-top: 1em;
    display: block;
    margin-left: auto;
    margin-right: auto;
    border: 1px solid;
}
#hide-event-btn {
    background: #5a3a00;
    color: #ffcc80;
    border-color: #ffcc80;
}
#hide-event-btn:hover {
    background: #ffcc80;
    color: #5a3a00;
}
#unhide-event-btn {
    background: #004d40;
    color: #80cbc4;
    border-color: #80cbc4;
}
#unhide-event-btn:hover {
    background: #80cbc4;
    color: #004d40;
}


  </style>
</head>
<body>
  <button id="settings-btn" title="Settings">⚙️</button>
  <div id="current-time">Loading time...</div>
  
  <div id="main-content-wrapper">
    <div id="all-day-container"></div>
    <div id="events"></div>
  </div>

  <div id="fullscreen">
	  <div class="content" id="fullscreen-content"></div>
	</div>

  <!-- Settings Modal -->
  <div id="settings-modal">
    <div class="settings-panel">
      <button class="close-btn" id="settings-close-btn">&times;</button>
      <h2>Settings</h2>

      <!-- "Show Events" Radio Buttons -->
      <fieldset class="count-options-fieldset">
        <legend>Show Events</legend>
        <div class="radio-option">
            <input type="radio" id="count-tomorrow" name="count-type" value="tomorrow">
            <label for="count-tomorrow">Today & Tomorrow</label>
        </div>
        <div class="radio-option">
            <input type="radio" id="count-today" name="count-type" value="today">
            <label for="count-today">Today Only</label>
        </div>
        <div class="radio-option">
            <input type="radio" id="count-this_week" name="count-type" value="this_week">
            <label for="count-this_week">This Week</label>
        </div>
        <div class="radio-option">
            <input type="radio" id="count-all" name="count-type" value="all">
            <label for="count-all">All Future Events</label>
        </div>
        <div class="radio-option">
            <input type="radio" id="count-custom" name="count-type" value="custom">
            <label for="count-custom">Next</label>
            <input type="number" id="custom-count-input" min="1" value="3" disabled>
            <span>&nbsp;events</span>
        </div>
      </fieldset>

      <div class="setting-row">
        <label for="layout-setting">Split Column Layout</label>
        <label class="switch">
            <input type="checkbox" id="layout-setting">
            <span class="slider"></span>
        </label>
      </div>
      <!-- div class="setting-row">
        <label for="private-setting">Show Private Details</label>
        <label class="switch">
            <input type="checkbox" id="private-setting">
            <span class="slider"></span>
        </label>
      </div -->
      <div class="setting-row">
        <label for="trans-setting">Transparent BG</label>
        <label class="switch">
            <input type="checkbox" id="trans-setting">
            <span class="slider"></span>
        </label>
      </div>
      <div class="setting-row">
        <label for="show-hidden-setting">Show Hidden Events</label>
        <label class="switch">
            <input type="checkbox" id="show-hidden-setting">
            <span class="slider"></span>
        </label>
      </div>
      <div class="setting-row">
        <label for="file-setting">Data File Name</label>
        <input type="text" id="file-setting">
      </div>
      <button id="save-settings-btn">Save & Reload</button>
    </div>
  </div>

  <script>
    const urlParams = new URLSearchParams(window.location.search);
	
	const defaults = {
		file: 'calendar.csv',
		count: 'tomorrow',
		private: false,
		trans: false,
        showHidden: false,
        layout: 'top' // 'top' or 'split'
	};
	let settings = { ...defaults, ...JSON.parse(localStorage.getItem('eventSettings')) };
    let hiddenEvents = new Set(JSON.parse(localStorage.getItem('hiddenEvents')) || []);

	// URL parameters have priority over saved settings
	const fileName = urlParams.get('file') || settings.file;
	const countParam = urlParams.get('count') || settings.count;
	const privateOverride = urlParams.has('private') ? urlParams.get('private') === '1' : settings.private;
	const transparentBg = urlParams.has('trans') ? urlParams.get('trans') === '1' : settings.trans;
    const showHiddenOverride = urlParams.has('showHidden') ? urlParams.get('showHidden') === '1' : settings.showHidden;
    const layoutOverride = urlParams.get('layout') || settings.layout;


    const nowParam = urlParams.get('now');
	const shownEventDetails = new Set();
	let autoCloseTimeout = null;
	const autoCloseDuration = 10000;

	if (transparentBg) {
	  const style = document.createElement('style');
	  style.textContent = `
		body { background: transparent !important; }
		#fullscreen { background: transparent !important; }
		.details-card, .event {
		  background: rgba(30,40,60,0.8) !important;
		}
	  `;
	  document.head.appendChild(style);
	}
    if (layoutOverride === 'split') {
        document.body.classList.add('layout-split-column');
    }

	
    let fakeNow = nowParam ? new Date(nowParam) : null;
    let eventsData = [];

	// --- Settings Management Functions ---
	function updateSettingsForm() {
        document.getElementById('file-setting').value = fileName;
        document.getElementById('private-setting').checked = privateOverride;
        document.getElementById('trans-setting').checked = transparentBg;
        document.getElementById('show-hidden-setting').checked = showHiddenOverride;
        document.getElementById('layout-setting').checked = layoutOverride === 'split';

        // Handle radio buttons for 'count'
        const customCountInput = document.getElementById('custom-count-input');
        if (/^\d+$/.test(countParam)) {
            document.getElementById('count-custom').checked = true;
            customCountInput.value = countParam;
            customCountInput.disabled = false;
        } else {
            const radio = document.getElementById(`count-${countParam}`);
            if (radio) radio.checked = true;
            else document.getElementById('count-tomorrow').checked = true; // Default
            customCountInput.disabled = true;
        }
	}

	function saveSettings() {
        let countValue;
        if (document.getElementById('count-custom').checked) {
            countValue = document.getElementById('custom-count-input').value || '3';
        } else {
            countValue = document.querySelector('input[name="count-type"]:checked').value;
        }

		const newSettings = {
			file: document.getElementById('file-setting').value,
			count: countValue,
			private: document.getElementById('private-setting').checked,
			trans: document.getElementById('trans-setting').checked,
            showHidden: document.getElementById('show-hidden-setting').checked,
            layout: document.getElementById('layout-setting').checked ? 'split' : 'top'
		};
		localStorage.setItem('eventSettings', JSON.stringify(newSettings));
		alert('Settings saved. The page will now reload to apply them.');
		// Reload the page at its base path, clearing any URL params
		window.location.href = window.location.pathname;
	}
	
	function setupSettingsModal() {
		const settingsBtn = document.getElementById('settings-btn');
		const settingsModal = document.getElementById('settings-modal');
		const closeBtn = document.getElementById('settings-close-btn');
		const saveBtn = document.getElementById('save-settings-btn');
        const countRadios = document.querySelectorAll('input[name="count-type"]');
        const customCountInput = document.getElementById('custom-count-input');
		
		settingsBtn.onclick = () => {
			updateSettingsForm(); // Ensure form shows current settings
			settingsModal.style.display = 'flex'; // Use flex to center the panel
		};
		closeBtn.onclick = () => settingsModal.style.display = 'none';
		saveBtn.onclick = saveSettings;
		// Close if user clicks outside the panel
		settingsModal.onclick = (e) => {
			if (e.target === settingsModal) {
				settingsModal.style.display = 'none';
			}
		};

        // Enable/disable custom count input
        countRadios.forEach(radio => {
            radio.addEventListener('change', () => {
                customCountInput.disabled = (radio.value !== 'custom');
            });
        });
	}

    function cleanupHiddenEvents() {
        const now = fakeNow ? new Date(fakeNow.getTime()) : new Date();
        let changed = false;
        const allEventIds = new Set(eventsData.map(generateId));
        
        hiddenEvents.forEach(id => {
            const event = eventsData.find(e => generateId(e) === id);
            // Remove if event is over OR if it's no longer in the main data source
            if (!event || new Date(event.end) < now) {
                hiddenEvents.delete(id);
                changed = true;
            }
        });

        if (changed) {
            localStorage.setItem('hiddenEvents', JSON.stringify(Array.from(hiddenEvents)));
        }
    }

    function updateTime() {
	  const now = fakeNow ? new Date(fakeNow.getTime()) : new Date();
	  document.getElementById('current-time').innerText = now.toLocaleTimeString();
	  if (fakeNow) fakeNow.setSeconds(fakeNow.getSeconds() + 1);

	  // Only updates timers, does not trigger full render
	  Array.from(document.querySelectorAll('.event')).forEach(el => {
		const start = new Date(el.dataset.start);
		const end = new Date(el.dataset.end);
		const msUntil = start - now;
		const msUntilEnd = end - now;
		const timeDiv = el.querySelector('.time-until, .big-time');

		// --- LOGIC TO UPDATE COLOURS/CLASSES DYNAMICALLY ---
		el.classList.remove('happening-now', 'final-countdown', 'starting-soon');
		if ((start <= now) && (end > now)) {
		  el.classList.add('happening-now');
		  const eventId = el.dataset.id;
		  const msSinceStart = now - start;
		  
		  if (msSinceStart <= autoCloseDuration && !shownEventDetails.has(eventId)) {
			shownEventDetails.add(eventId);
			showDetailsById(eventId, { glow: true });
		  }

		} else if (msUntil > 0 && msUntil <= 2 * 60 * 1000) {
		  el.classList.add('final-countdown');
		} else if (msUntil > 2 * 60 * 1000 && msUntil < 10 * 60 * 1000) {
		  el.classList.add('starting-soon');
		}

		if (end <= now && !el.classList.contains('slide-out')) {
		  el.classList.remove('slide-in', 'slide-in-active');
		  el.classList.add('slide-out');
		  setTimeout(() => el.remove(), 500);
		}
		if (timeDiv) {
		  timeDiv.className = (msUntil > 0 && msUntil < 10 * 60 * 1000) ? 'big-time' : 'time-until';
		  timeDiv.textContent = msUntil > 0 ? formatDuration(msUntil) : (end > now ? 'Happening now' : 'Started');
		}
	  });
	}

	function formatDurationMinutes(start, end) {
	  const ms = end - start;
	  const totalMinutes = Math.round(ms / 60000);
	  const hours = Math.floor(totalMinutes / 60);
	  const minutes = totalMinutes % 60;
	  let text = '';
	  if (hours > 0) text += `${hours} hour${hours !== 1 ? 's' : ''} `;
	  if (minutes > 0 || hours === 0) text += `${minutes} min${minutes !== 1 ? 's' : ''}`;
	  return text.trim();
	}

    function generateId(e) {
      return `${e.start}_${e.summary}`;
    }

    function isAllDayEvent(e) {
        const start = new Date(e.start);
        const end = new Date(e.end);
        const durationHours = (end - start) / (1000 * 60 * 60);
        const startsAtMidnight = start.getHours() === 0 && start.getMinutes() === 0 && start.getSeconds() === 0;
        // Use >= 23 hours to account for daylight saving changes
        return durationHours >= 23 && startsAtMidnight;
    }

    function renderTodaysAllDayEvents(events, now) {
        const container = document.getElementById('all-day-container');
        container.innerHTML = ''; // Clear previous content

        if (events.length > 0) {
            const title = document.createElement('div');
            title.className = 'all-day-title';
            title.textContent = "Today's All-Day Events";
            container.appendChild(title);

            events.forEach(e => {
                const el = document.createElement('div');
                el.className = 'all-day-event';
                el.textContent = e.summary;
                el.onclick = () => showDetailsById(generateId(e));
                container.appendChild(el);
            });
        }
    }

    function renderEvents(now) {
      cleanupHiddenEvents();
	  
      const visibleEvents = eventsData.filter(e => {
        const id = generateId(e);
        const isHidden = hiddenEvents.has(id) && !showHiddenOverride;
        return !isHidden && e.rsvp !== 'declined' && new Date(e.end) >= now && e.ooo !== 'yes';
      });

      const todaysAllDayEvents = [];
      const otherEvents = [];

      visibleEvents.forEach(e => {
          if (isAllDayEvent(e) && isSameDay(new Date(e.start), now)) {
              todaysAllDayEvents.push(e);
          } else {
              otherEvents.push(e);
          }
      });

      renderTodaysAllDayEvents(todaysAllDayEvents, now);

      let filtered = otherEvents.sort((a, b) => new Date(a.start) - new Date(b.start));

      if (/^\d+$/.test(countParam)) {
        filtered = filtered.slice(0, parseInt(countParam));
      } else if (countParam === 'today') {
        filtered = filtered.filter(e => isSameDay(new Date(e.start), now));
      } else if (countParam === 'tomorrow') {
        const tomorrow = new Date(now);
        tomorrow.setDate(now.getDate() + 1);
        filtered = filtered.filter(e => isSameDay(new Date(e.start), tomorrow) || isSameDay(new Date(e.start), now));
      } else if (countParam === 'this_week') {
        const endOfWeek = new Date(now);
        endOfWeek.setDate(now.getDate() + (7 - now.getDay()));
        endOfWeek.setHours(23, 59, 59, 999);
        filtered = filtered.filter(e => new Date(e.start) <= endOfWeek);
      } else if (countParam !== 'all') {
        // This is a fallback, 'all' will show all timedEvents
      }

      const eventsDiv = document.getElementById('events');
      const existingEls = Array.from(eventsDiv.querySelectorAll('.event'));
      const newIds = filtered.map(generateId);
      const elsToRemove = existingEls.filter(el => !newIds.includes(el.dataset.id));
      const newEvents = filtered.filter(e => !document.querySelector(`[data-id="${generateId(e)}"]`));

      removeEventsSequentially(elsToRemove, () => {
        insertEventsSequentially(newEvents, now);
      });
    }

    function removeEventsSequentially(els, callback, index = 0) {
		  if (index >= els.length) return callback();
		  const el = els[index];
		  el.classList.remove('slide-in', 'slide-in-active');
		  el.classList.add('slide-out');

		  const eventsDiv = document.getElementById('events');
		  Array.from(eventsDiv.children).forEach(child => {
			if (child.classList && child.classList.contains('event') && child !== el) {
			  child.classList.remove('slide-in', 'slide-in-active', 'slide-out');
			}
		  });

		  const prevRects = [];
		  Array.from(eventsDiv.children).forEach(child => {
			if (child !== el && child.classList.contains('event')) {
			  prevRects.push({
				el: child,
				top: child.getBoundingClientRect().top
			  });
			}
		  });

		  setTimeout(() => {
			el.remove();

			const newRects = [];
			Array.from(eventsDiv.children).forEach(child => {
			  if (child.classList.contains('event')) {
				newRects.push({
				  el: child,
				  top: child.getBoundingClientRect().top
				});
			  }
			});

			newRects.forEach((newRect, i) => {
			  const prevRect = prevRects.find(r => r.el === newRect.el);
			  if (prevRect) {
				const dy = prevRect.top - newRect.top;
				if (dy) {
				  newRect.el.classList.add('event-animating');
				  newRect.el.style.transform = `translateY(${dy}px)`;
				  void newRect.el.offsetWidth;
				  newRect.el.style.transform = '';
				  setTimeout(() => newRect.el.classList.remove('event-animating'), 500);
				}
			  }
			});

			removeEventsSequentially(els, callback, index + 1);
		  }, 500);
		}

	function showDetailsById(id, options = {}) {
	  const e = eventsData.find(ev => generateId(ev) === id);
	  if (!e) {
		console.error("Sorry, event not found for ID:", id);
		return;
	  }

		const fullscreen = document.getElementById('fullscreen');
		if (autoCloseTimeout) {
			clearTimeout(autoCloseTimeout);
			autoCloseTimeout = null;
		}
		  
		if (options.glow && !isAllDayEvent(e)) { // Don't auto-glow for all-day events
			fullscreen.classList.add('auto-glow');
			autoCloseTimeout = setTimeout(() => {
			  fullscreen.style.display = 'none';
			  fullscreen.classList.remove('auto-glow');
			}, autoCloseDuration); 
		} else {
			fullscreen.classList.remove('auto-glow');
		}

	  const startDate = new Date(e.start);
	  const endDate = new Date(e.end);
	  const dateString = startDate.toLocaleDateString(undefined, { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });
	  const startTime = formatTimeOnly(startDate);
	  const endTime = formatTimeOnly(endDate);
	  const duration = formatDurationMinutes(startDate, endDate);
	  const rsvp = e.rsvp.charAt(0).toUpperCase() + e.rsvp.slice(1);
	  const privacy = e.private === 'yes' ? "Private" : "Public";
      
      const isHidden = hiddenEvents.has(id);
      const buttonId = isHidden ? 'unhide-event-btn' : 'hide-event-btn';
      const buttonText = isHidden ? 'Unhide this event' : 'Hide this event';
      const toggleButtonHTML = `<button id="${buttonId}" class="details-action-btn" data-id="${id}">${buttonText}</button>`;

	  document.getElementById('fullscreen-content').innerHTML = `
		  <div class="details-card">
			<button class="close-btn" onclick="
			  document.getElementById('fullscreen').style.display = 'none';
			  document.getElementById('fullscreen').classList.remove('auto-glow');
			  if (window.autoCloseTimeout) { clearTimeout(window.autoCloseTimeout); autoCloseTimeout = null; }
			">&times;</button>
			<div class="details-title">${e.summary}</div>
			<div class="details-row details-date"><span class="details-label">Date:</span> ${dateString}</div>
            ${!isAllDayEvent(e) ? `<div class="details-row"><span class="details-label">Time:</span> ${startTime} &ndash; ${endTime}</div>` : ''}
			<div class="details-row"><span class="details-label">Duration:</span> ${duration}</div>
			<div class="details-row"><span class="details-label">RSVP:</span> ${rsvp}</div>
			<div class="details-row"><span class="details-label">Privacy:</span> ${privacy}</div>
			<div class="details-description">
			  <span class="details-label">Description:</span>
			  <span>
				${(privateOverride || e.private !== 'yes')
				   ? (e.description || '<i>No description</i>')
				   : '<i>Details hidden</i>'}
			  </span>
			</div>
            ${toggleButtonHTML}
		  </div>
		`;
      
      document.querySelector('.details-action-btn').onclick = (evt) => {
          const eventIdToToggle = evt.target.dataset.id;
          if (hiddenEvents.has(eventIdToToggle)) {
              hiddenEvents.delete(eventIdToToggle);
          } else {
              hiddenEvents.add(eventIdToToggle);
          }
          localStorage.setItem('hiddenEvents', JSON.stringify(Array.from(hiddenEvents)));
          document.getElementById('fullscreen').style.display = 'none';
          renderEvents(fakeNow || new Date());
      };

	  fullscreen.style.display = 'block';
	}


    function insertEventsSequentially(events, now, index = 0, lastDateStr = '') {
      if (index >= events.length) return;
      const e = events[index];
      const id = generateId(e);
      const start = new Date(e.start);
      const end = new Date(e.end);
      const msUntil = start - now;

      let cssClass = 'event';
      if ((start <= now) && (end > now)) cssClass += ' happening-now';
      else if (msUntil > 0 && msUntil <= 2 * 60 * 1000) cssClass += ' final-countdown';
      else if (msUntil > 2 * 60 * 1000 && msUntil < 10 * 60 * 1000) cssClass += ' starting-soon';

      let timeClass = 'time-until';
      if (msUntil > 0 && msUntil < 10 * 60 * 1000) timeClass = 'big-time';

      const dateStr = start.toLocaleDateString(undefined, { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });

      const eventsDiv = document.getElementById('events');

      if (dateStr !== lastDateStr) {
		  let needDivider = true;
		  let insertBefore = null;

		  for (let child of eventsDiv.children) {
			if (child.classList.contains('event')) {
			  const childStart = new Date(child.dataset.start);
			  const childDateStr = childStart.toLocaleDateString(undefined, { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });

			  if (dateStr === childDateStr) {
				if (child.previousElementSibling && child.previousElementSibling.classList.contains('date-divider') && child.previousElementSibling.textContent === dateStr) {
				  needDivider = false;
				} else {
				  insertBefore = child;
				}
				break;
			  }
			}
		  }

		  if (needDivider) {
			const divider = document.createElement('div');
			divider.className = 'date-divider';
			divider.textContent = dateStr;
			if (insertBefore) {
			  eventsDiv.insertBefore(divider, insertBefore);
			} else {
			  eventsDiv.appendChild(divider);
			}
		  }

		  lastDateStr = dateStr;
		}


      const el = document.createElement('div');
      el.className = cssClass + ' slide-in';
      el.dataset.id = id;
      el.dataset.start = e.start;
      el.dataset.end = e.end;
      el.dataset.msUntil = msUntil;
      el.onclick = () => showDetailsById(id);
      el.innerHTML = `
		  <strong>${e.summary}</strong><br/>
		  <span class="event-time-row">
			<span>${formatTimeOnly(start)}</span>
			<span class="event-duration">(${formatDurationMinutes(start, end)})</span>
		  </span>
		  <div class="${timeClass}">${formatDuration(msUntil)}</div>
		`;

		let inserted = false;
		for (let child of eventsDiv.children) {
		  if (child.classList.contains('event')) {
			const childStart = new Date(child.dataset.start);
			if (start < childStart) {
			  eventsDiv.insertBefore(el, child);
			  inserted = true;
			  break;
			}
		  }
		}
		if (!inserted) eventsDiv.appendChild(el);
      void el.offsetWidth;
      el.classList.add('slide-in-active');

      setTimeout(() => insertEventsSequentially(events, now, index + 1, lastDateStr), 300);
    }

    function isSameDay(d1, d2) {
      return d1.getFullYear() === d2.getFullYear() && d1.getMonth() === d2.getMonth() && d1.getDate() === d2.getDate();
    }

    function formatDuration(ms) {
      const totalSeconds = Math.max(0, Math.floor(ms / 1000));
      const days = Math.floor(totalSeconds / (60 * 60 * 24));
      const hours = Math.floor((totalSeconds % (60 * 60 * 24)) / 3600);
      const minutes = Math.floor((totalSeconds % 3600) / 60);
      const seconds = totalSeconds % 60;
      let parts = [];
      if (days > 0) parts.push(`${days} day${days !== 1 ? 's' : ''}`);
      if (hours > 0) parts.push(`${hours} hour${hours !== 1 ? 's' : ''}`);
      if (minutes > 0) parts.push(`${minutes} minute${minutes !== 1 ? 's' : ''}`);
      if (totalSeconds < 60) parts.push(`${seconds} second${seconds !== 1 ? 's' : ''}`);
      return parts.join(' ');
    }

    function formatTimeOnly(date) {
      return date.toLocaleTimeString(undefined, { hour: 'numeric', minute: '2-digit', hour12: true });
    }

    

    function parseCSV(data) {
      const lines = data.trim().split(/\r?\n/);
      if (lines.length < 2) return [];
      const headers = lines[0].split(",").map(h => h.trim().replace(/^"|"$/g, '').toLowerCase());
      return lines.slice(1).map(line => {
        const values = [];
        let current = '', inQuotes = false;
        for (let char of line) {
          if (char === '"') inQuotes = !inQuotes;
          else if (char === ',' && !inQuotes) { values.push(current.trim().replace(/^"|"$/g, '')); current = ''; }
          else current += char;
        }
        values.push(current.trim().replace(/^"|"$/g, ''));
        const obj = {};
        headers.forEach((h, i) => obj[h] = values[i] || "");
        return {
          summary: obj["subject"] || "No subject",
          start: obj["start"],
          end: obj["end"],
          description: obj["description"] || "",
          rsvp: (obj["rsvp"] || "").toLowerCase(),
          ooo: (obj["ooo"] || "").toLowerCase(),
          private: (obj["private"] || "").toLowerCase()
        };
      });
    }

    function fetchAndReloadData() {
	  console.log('Reloading event data (fetchAndReloadData) at', new Date().toLocaleTimeString());
      fetch(`${fileName}?_=${Date.now()}`)
        .then(r => r.text())
        .then(data => {
          if (fileName.endsWith(".csv")) {
            eventsData = parseCSV(data);
          }
          renderEvents(fakeNow ? new Date(fakeNow.getTime()) : new Date());
        })
        .catch(err => console.error("Failed to reload file:", err));
    }

	// --- Initial Setup ---
	setupSettingsModal();
    fetchAndReloadData();
	setInterval(updateTime, 1000);

	function scheduleNextReload() {
	  const now = fakeNow ? new Date(fakeNow.getTime()) : new Date();
	  let msToNext = (60 - now.getSeconds() + 1) % 60 * 1000 - now.getMilliseconds();
	  if (msToNext <= 0) msToNext += 60000; // just in case
	  console.log('msToNext:', msToNext);
	  
	  setTimeout(() => {
		fetchAndReloadData();
		setInterval(fetchAndReloadData, 60000); // After first precise reload, just repeat every minute
	  }, msToNext);
	}
	scheduleNextReload();

  </script>
</body>
</html>
